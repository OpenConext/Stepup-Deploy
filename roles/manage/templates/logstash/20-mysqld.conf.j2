filter {

  # Parse messages output my mysqld (MariaDB)

  # format to parse:
  # 150713 13:26:08 [Note] WSREP: bla bla bla
  # 2nd line

  if [prog] == "mysqld" {

    # (Try) to group messages split over multiple lines in one line again
    multiline {
      # Pattern matches the start of a new log message
      pattern => "^[0-9]{6} [0-9]{2}:[0-9]{1,2}:[0-9]{2} \["
      what => "previous"
      negate => true
    }

    # Multline may turn timestamp and received_at fields into an array
    # Fix this by setting those fields to the first value
    if "multiline" in [tags] {
      mutate {
        replace => [ "timestamp", "%{[timestamp][0]}" ]
        replace => [ "received_at", "%{[received_at][0]}" ]
      }
    }

    # Get the (non-standard) "YYMMdd (H)H:mm:ss" formatted timestamp and severity and replace the message
    grok {
      match => { message => "(?m)(?<mysql_timestamp>[0-9]{6} [0-9]{2}:[0-9]{1,2}:[0-9]{2}) \[(?<mysql_severity>[^\]]+)\] %{GREEDYDATA:message}" }
      overwrite => [ "message" ]
    }

    # Parse mysql_timestamp into generated_at
    date {
      match => [ "mysql_timestamp", "YYMMdd H:mm:ss", "YYMMdd HH:mm:ss" ]
      target => "generated_at"
    }

    # Mysql syslog reports all messages at error, replace severity with severity from the actual mysql logline
    mutate {
      rename => [ "mysql_severity", "severity" ]
    }

  }
}